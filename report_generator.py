#!/usr/bin/env python3
"""
Report Generator Module for Symphony Trading System

This module provides HTML report generation functionality with interactive charts 
and visualizations for Symphony Trading System analysis results.
"""

import os
import json
import base64
import logging
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import matplotlib.dates as mdates
from datetime import datetime
from io import BytesIO

# Configure logging
logger = logging.getLogger(__name__)

class ReportGenerator:
    """
    HTML report generator with visualization capabilities for trading system results.
    """
    
    def __init__(self, output_dir="symphony_analysis_results"):
        """
        Initialize the report generator.
        
        Args:
            output_dir (str): Directory to save HTML reports
        """
        self.output_dir = output_dir
        os.makedirs(output_dir, exist_ok=True)
        
        # Set matplotlib style for better-looking charts
        plt.style.use('ggplot')
    
    def generate_basic_report(self, results):
        """
        Generate a basic HTML report from analysis results.
        
        Args:
            results (dict): Analysis results from symphony_backtester
            
        Returns:
            str: Path to the generated HTML report
        """
        logger.info("Generating basic HTML report")
        
        if "error" in results:
            logger.error(f"Cannot generate report due to analysis error: {results['error']}")
            return None
            
        symphony_name = results['symphony_info']['name']
        file_name = results['symphony_info']['file']
        
        # Create HTML report
        html = f"""<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Symphony Analysis: {symphony_name}</title>
    <style>
        body {{ font-family: Arial, sans-serif; margin: 0; padding: 20px; }}
        .container {{ max-width: 1200px; margin: 0 auto; }}
        header {{ background-color: #f5f5f5; padding: 20px; margin-bottom: 20px; border-radius: 5px; }}
        h1, h2, h3 {{ color: #333; }}
        .section {{ margin-bottom: 30px; border: 1px solid #ddd; padding: 20px; border-radius: 5px; }}
        .metric {{ display: inline-block; margin-right: 30px; margin-bottom: 15px; }}
        .metric .value {{ font-size: 24px; font-weight: bold; }}
        .metric .label {{ font-size: 14px; color: #666; }}
        table {{ width: 100%; border-collapse: collapse; }}
        table, th, td {{ border: 1px solid #ddd; }}
        th, td {{ padding: 10px; text-align: left; }}
        th {{ background-color: #f5f5f5; }}
        .chart {{ margin-top: 20px; }}
        .positive {{ color: green; }}
        .negative {{ color: red; }}
        .neutral {{ color: gray; }}
        footer {{ margin-top: 30px; padding-top: 10px; border-top: 1px solid #ddd; color: #666; font-size: 12px; }}
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>Symphony Analysis Report</h1>
            <p>Symphony: <strong>{symphony_name}</strong></p>
            <p>File: {file_name}</p>
            <p>Date: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}</p>
        </header>
"""
        
        # Symphony Info Section
        html += self._generate_symphony_info_section(results['symphony_info'])
        
        # Backtest Results Section
        if 'backtest_results' in results and 'backtest_summary' in results['backtest_results']:
            html += self._generate_backtest_section(results['backtest_results'])
        
        # Benchmark Comparison Section
        if 'benchmark_comparison' in results and 'benchmark_symbol' in results['benchmark_comparison']:
            html += self._generate_benchmark_section(results['benchmark_comparison'])
        
        # Forecast Section
        if 'forecasts' in results:
            html += self._generate_forecast_section(results['forecasts'], results['symphony_info'])
        
        # Risk Analysis Section
        if 'risk_analysis' in results:
            html += self._generate_risk_section(results['risk_analysis'])
        
        # Footer
        html += f"""
        <footer>
            <p>Generated by Symphony Trading System on {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}</p>
        </footer>
    </div>
</body>
</html>
"""
        
        # Write HTML to file
        report_file = os.path.join(self.output_dir, f"{symphony_name}_report.html")
        with open(report_file, 'w') as f:
            f.write(html)
        
        logger.info(f"Generated basic HTML report: {report_file}")
        return report_file

    def generate_enhanced_report(self, results):
        """
        Generate an enhanced HTML report with visualizations from analysis results.
        
        Args:
            results (dict): Analysis results from symphony_backtester
            
        Returns:
            str: Path to the generated HTML report
        """
        logger.info("Generating enhanced HTML report")
        
        if "error" in results:
            logger.error(f"Cannot generate report due to analysis error: {results['error']}")
            return None
            
        # Extract basic symphony info
        symphony_name = results['symphony_info']['name']
        file_name = results['symphony_info']['file']
        
        # Start building HTML
        html = self._generate_html_header(symphony_name)
        
        # Symphony Info Section
        html += self._generate_symphony_info_section(results['symphony_info'])
        
        # Backtest Results Section
        if 'backtest_results' in results and 'backtest_summary' in results['backtest_results']:
            html += self._generate_backtest_section(results['backtest_results'])
            
            # Add equity curve chart
            if 'portfolio_values' in results['backtest_results']:
                chart_html = self._generate_equity_curve_chart(results['backtest_results'])
                html += chart_html
                
            # Add drawdown chart
            if 'drawdowns' in results['backtest_results']:
                chart_html = self._generate_drawdown_chart(results['backtest_results'])
                html += chart_html
        
        # Benchmark Comparison Section
        if 'benchmark_comparison' in results and 'benchmark_symbol' in results['benchmark_comparison']:
            html += self._generate_benchmark_section(results['benchmark_comparison'])
            
            # Add relative performance chart
            if ('portfolio_values' in results['backtest_results'] and 
                'benchmark_values' in results['benchmark_comparison']):
                chart_html = self._generate_relative_performance_chart(
                    results['backtest_results'], 
                    results['benchmark_comparison']
                )
                html += chart_html
        
        # Forecast Section
        if 'forecasts' in results:
            html += self._generate_forecast_section(results['forecasts'], results['symphony_info'])
            
            # Add forecast charts
            chart_html = self._generate_forecast_charts(results['forecasts'], results['symphony_info'])
            html += chart_html
        
        # Risk Analysis Section
        if 'risk_analysis' in results:
            html += self._generate_risk_section(results['risk_analysis'])
            
            # Add risk visualization
            chart_html = self._generate_risk_chart(results['risk_analysis'])
            html += chart_html
        
        # Add interactive section 
        if 'backtest_results' in results and 'portfolio_values' in results['backtest_results']:
            html += self._generate_interactive_section(results)
        
        # Add footer and close HTML
        html += f"""
        <footer>
            <p>Generated by Symphony Trading System on {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}</p>
            <p>Enhanced HTML Report Generator v1.0.0</p>
        </footer>
    </div>
</body>
</html>
"""
        
        # Write HTML to file
        report_file = os.path.join(self.output_dir, f"{symphony_name}_enhanced_report.html")
        with open(report_file, 'w') as f:
            f.write(html)
        
        logger.info(f"Generated enhanced HTML report: {report_file}")
        return report_file
    
    def _generate_html_header(self, symphony_name):
        """Generate HTML header with CSS and JavaScript"""
        return f"""<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Symphony Analysis: {symphony_name}</title>
    
    <!-- Add Bootstrap CSS -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/css/bootstrap.min.css" rel="stylesheet">
    
    <!-- Add custom CSS -->
    <style>
        body {{ font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; margin: 0; padding: 20px; background-color: #f8f9fa; }}
        .container {{ max-width: 1200px; margin: 0 auto; }}
        header {{ background-color: #343a40; color: white; padding: 20px; margin-bottom: 20px; border-radius: 5px; }}
        h1, h2, h3 {{ color: #343a40; }}
        .section {{ margin-bottom: 30px; border: 1px solid #ddd; padding: 20px; border-radius: 5px; background-color: white; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }}
        .metric {{ display: inline-block; margin-right: 30px; margin-bottom: 15px; background-color: #f8f9fa; padding: 15px; border-radius: 5px; min-width: 150px; }}
        .metric .value {{ font-size: 24px; font-weight: bold; }}
        .metric .label {{ font-size: 14px; color: #666; }}
        table {{ width: 100%; border-collapse: collapse; margin-bottom: 20px; }}
        table, th, td {{ border: 1px solid #ddd; }}
        th, td {{ padding: 10px; text-align: left; }}
        th {{ background-color: #f5f5f5; }}
        .chart {{ margin-top: 20px; background-color: white; padding: 10px; border-radius: 5px; box-shadow: 0 1px 3px rgba(0,0,0,0.1); }}
        .chart-container {{ margin-top: 15px; height: 400px; }}
        .positive {{ color: #28a745; }}
        .negative {{ color: #dc3545; }}
        .neutral {{ color: #6c757d; }}
        footer {{ margin-top: 30px; padding-top: 10px; border-top: 1px solid #ddd; color: #666; font-size: 12px; }}
        .tab-content {{ padding: 20px; background-color: white; border: 1px solid #dee2e6; border-top: none; border-radius: 0 0 5px 5px; }}
        .nav-tabs {{ margin-bottom: 0; }}
    </style>
    
    <!-- Add Bootstrap JS and Popper.js -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/js/bootstrap.bundle.min.js"></script>
    
    <!-- Add Chart.js for better charts -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
</head>
<body>
    <div class="container">
        <header>
            <h1>Symphony Analysis Report</h1>
            <p>Symphony: <strong>{symphony_name}</strong></p>
            <p>Date: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}</p>
        </header>
"""
    
    def _generate_symphony_info_section(self, symphony_info):
        """Generate the symphony information section"""
        symbols = ', '.join(symphony_info['symbols'])
        
        html = f"""
        <div class="section">
            <h2>Symphony Information</h2>
            <div class="row">
                <div class="col-md-4">
                    <div class="metric">
                        <div class="label">Name</div>
                        <div class="value">{symphony_info['name']}</div>
                    </div>
                </div>
                <div class="col-md-4">
                    <div class="metric">
                        <div class="label">Symbols</div>
                        <div class="value">{len(symphony_info['symbols'])}</div>
                    </div>
                </div>
                <div class="col-md-4">
                    <div class="metric">
                        <div class="label">File</div>
                        <div class="value" style="font-size: 16px;">{os.path.basename(symphony_info['file'])}</div>
                    </div>
                </div>
            </div>
            <h3>Universe</h3>
            <p>{symbols}</p>
        """
        
        # Add strategy description if available
        if 'description' in symphony_info and symphony_info['description']:
            html += f"""
            <h3>Description</h3>
            <p>{symphony_info['description']}</p>
            """
        
        html += "</div>"
        return html
    
    def _generate_backtest_section(self, backtest_results):
        """Generate the backtest results section"""
        summary = backtest_results['backtest_summary']
        total_return = summary.get('total_return', 0) * 100
        annual_return = summary.get('annualized_return', 0) * 100
        max_drawdown = summary.get('max_drawdown', 0) * 100
        sharpe = summary.get('sharpe_ratio', 0)
        volatility = summary.get('volatility', 0) * 100 if 'volatility' in summary else 0
        
        html = f"""
        <div class="section">
            <h2>Backtest Results</h2>
            <div class="row">
                <div class="col-md-4">
                    <div class="metric">
                        <div class="label">Total Return</div>
                        <div class="value {self._get_color_class(total_return)}">{total_return:.2f}%</div>
                    </div>
                </div>
                <div class="col-md-4">
                    <div class="metric">
                        <div class="label">Annualized Return</div>
                        <div class="value {self._get_color_class(annual_return)}">{annual_return:.2f}%</div>
                    </div>
                </div>
                <div class="col-md-4">
                    <div class="metric">
                        <div class="label">Max Drawdown</div>
                        <div class="value {self._get_color_class(-max_drawdown)}">{max_drawdown:.2f}%</div>
                    </div>
                </div>
            </div>
            <div class="row mt-3">
                <div class="col-md-4">
                    <div class="metric">
                        <div class="label">Sharpe Ratio</div>
                        <div class="value {self._get_color_class(sharpe)}">{sharpe:.2f}</div>
                    </div>
                </div>
                <div class="col-md-4">
                    <div class="metric">
                        <div class="label">Volatility</div>
                        <div class="value {self._get_color_class(-volatility)}">{volatility:.2f}%</div>
                    </div>
                </div>
                <div class="col-md-4">
                    <div class="metric">
                        <div class="label">Win Rate</div>
                        <div class="value {self._get_color_class(summary.get('win_rate', 0) * 100 - 50)}>{summary.get('win_rate', 0) * 100:.1f}%</div>
                    </div>
                </div>
            </div>
        </div>
        """
        return html
    
    def _generate_benchmark_section(self, benchmark_comparison):
        """Generate the benchmark comparison section"""
        benchmark_symbol = benchmark_comparison['benchmark_symbol']
        benchmark_return = benchmark_comparison.get('benchmark_return', 0) * 100
        portfolio_return = benchmark_comparison.get('portfolio_return', 0) * 100
        excess_return = benchmark_comparison.get('excess_return', 0) * 100
        beta = benchmark_comparison.get('beta', 0)
        correlation = benchmark_comparison.get('correlation', 0)
        info_ratio = benchmark_comparison.get('information_ratio', 0)
        
        html = f"""
        <div class="section">
            <h2>Benchmark Comparison ({benchmark_symbol})</h2>
            <div class="row">
                <div class="col-md-4">
                    <div class="metric">
                        <div class="label">Benchmark Return</div>
                        <div class="value {self._get_color_class(benchmark_return)}">{benchmark_return:.2f}%</div>
                    </div>
                </div>
                <div class="col-md-4">
                    <div class="metric">
                        <div class="label">Portfolio Return</div>
                        <div class="value {self._get_color_class(portfolio_return)}">{portfolio_return:.2f}%</div>
                    </div>
                </div>
                <div class="col-md-4">
                    <div class="metric">
                        <div class="label">Excess Return</div>
                        <div class="value {self._get_color_class(excess_return)}">{excess_return:.2f}%</div>
                    </div>
                </div>
            </div>
            <div class="row mt-3">
                <div class="col-md-4">
                    <div class="metric">
                        <div class="label">Beta</div>
                        <div class="value">{beta:.2f}</div>
                    </div>
                </div>
                <div class="col-md-4">
                    <div class="metric">
                        <div class="label">Correlation</div>
                        <div class="value">{correlation:.2f}</div>
                    </div>
                </div>
                <div class="col-md-4">
                    <div class="metric">
                        <div class="label">Information Ratio</div>
                        <div class="value {self._get_color_class(info_ratio)}">{info_ratio:.2f}</div>
                    </div>
                </div>
            </div>
        </div>
        """
        return html
    
    def _generate_forecast_section(self, forecasts, symphony_info):
        """Generate the forecast section"""
        forecast_30d = forecasts.get('average_30d_forecast', 0)
        sentiment = forecasts.get('forecast_sentiment', 'unknown')
        
        html = f"""
        <div class="section">
            <h2>Forecast</h2>
            <div class="row">
                <div class="col-md-6">
                    <div class="metric">
                        <div class="label">30-Day Average Forecast</div>
                        <div class="value {self._get_color_class(forecast_30d)}">{forecast_30d:.2f}%</div>
                    </div>
                </div>
                <div class="col-md-6">
                    <div class="metric">
                        <div class="label">Forecast Sentiment</div>
                        <div class="value {sentiment}">{sentiment.title()}</div>
                    </div>
                </div>
            </div>
            <h3>Symbol Forecasts</h3>
            <div class="table-responsive">
                <table class="table table-striped">
                    <thead>
                        <tr>
                            <th>Symbol</th>
                            <th>7-Day Forecast</th>
                            <th>30-Day Forecast</th>
                            <th>Confidence</th>
                        </tr>
                    </thead>
                    <tbody>
        """
        
        for symbol in symphony_info['symbols']:
            if symbol in forecasts:
                symbol_forecast = forecasts[symbol]
                forecast_7d = symbol_forecast.get('7_day', {}).get('percent_change', 0)
                forecast_30d = symbol_forecast.get('30_day', {}).get('percent_change', 0)
                confidence = symbol_forecast.get('confidence', 0.5) * 100
                
                html += f"""
                    <tr>
                        <td><strong>{symbol}</strong></td>
                        <td class="{self._get_color_class(forecast_7d)}">{forecast_7d:.2f}%</td>
                        <td class="{self._get_color_class(forecast_30d)}">{forecast_30d:.2f}%</td>
                        <td>{confidence:.0f}%</td>
                    </tr>
                """
        
        html += """
                    </tbody>
                </table>
            </div>
        </div>
        """
        return html
    
    def _generate_risk_section(self, risk_analysis):
        """Generate the risk analysis section"""
        volatility = risk_analysis.get('volatility', 0) * 100
        max_drawdown = risk_analysis.get('max_drawdown', 0) * 100
        sortino = risk_analysis.get('sortino_ratio', 0)
        downside_dev = risk_analysis.get('downside_deviation', 0) * 100
        
        html = f"""
        <div class="section">
            <h2>Risk Analysis</h2>
            <div class="row">
                <div class="col-md-3">
                    <div class="metric">
                        <div class="label">Volatility</div>
                        <div class="value {self._get_color_class(-volatility)}">{volatility:.2f}%</div>
                    </div>
                </div>
                <div class="col-md-3">
                    <div class="metric">
                        <div class="label">Max Drawdown</div>
                        <div class="value {self._get_color_class(-max_drawdown)}">{max_drawdown:.2f}%</div>
                    </div>
                </div>
                <div class="col-md-3">
                    <div class="metric">
                        <div class="label">Sortino Ratio</div>
                        <div class="value {self._get_color_class(sortino)}">{sortino:.2f}</div>
                    </div>
                </div>
                <div class="col-md-3">
                    <div class="metric">
                        <div class="label">Downside Deviation</div>
                        <div class="value {self._get_color_class(-downside_dev)}">{downside_dev:.2f}%</div>
                    </div>
                </div>
            </div>
        """
        
        # Add risk table if available
        if 'monthly_returns' in risk_analysis:
            monthly_returns = risk_analysis['monthly_returns']
            if isinstance(monthly_returns, dict):
                html += """
                <h3 class="mt-4">Monthly Returns</h3>
                <div class="table-responsive">
                    <table class="table table-sm table-bordered">
                        <thead>
                            <tr>
                                <th>Year</th>
                                <th>Jan</th>
                                <th>Feb</th>
                                <th>Mar</th>
                                <th>Apr</th>
                                <th>May</th>
                                <th>Jun</th>
                                <th>Jul</th>
                                <th>Aug</th>
                                <th>Sep</th>
                                <th>Oct</th>
                                <th>Nov</th>
                                <th>Dec</th>
                                <th>YTD</th>
                            </tr>
                        </thead>
                        <tbody>
                """
                
                for year, months in sorted(monthly_returns.items()):
                    if isinstance(months, dict):
                        ytd = sum([float(v) for v in months.values() if isinstance(v, (int, float))])
                        html += f"<tr><td><strong>{year}</strong></td>"
                        
                        for month in range(1, 13):
                            month_str = str(month)
                            if month_str in months:
                                value = float(months[month_str]) * 100
                                html += f'<td class="{self._get_color_class(value)}">{value:.1f}%</td>'
                            else:
                                html += "<td>-</td>"
                        
                        html += f'<td class="{self._get_color_class(ytd*100)}"><strong>{ytd*100:.1f}%</strong></td></tr>'
                
                html += """
                        </tbody>
                    </table>
                </div>
                """
        
        html += "</div>"
        return html
    
    def _generate_equity_curve_chart(self, backtest_results):
        """Generate equity curve chart"""
        if 'portfolio_values' not in backtest_results:
            return ""
        
        try:
            # Create a figure for the equity curve
            plt.figure(figsize=(10, 6))
            
            # Extract portfolio values
            portfolio_values = backtest_results['portfolio_values']
            
            # If we have a dictionary with dates
            if isinstance(portfolio_values, dict):
                dates = list(portfolio_values.keys())
                values = list(portfolio_values.values())
                
                # Try to parse dates
                try:
                    dates = [datetime.strptime(d, '%Y-%m-%d') for d in dates]
                    plt.plot(dates, values, 'b-', linewidth=2)
                    plt.gca().xaxis.set_major_formatter(mdates.DateFormatter('%Y-%m-%d'))
                    plt.gca().xaxis.set_major_locator(mdates.MonthLocator(interval=3))
                except:
                    plt.plot(values, 'b-', linewidth=2)
            else:
                plt.plot(portfolio_values, 'b-', linewidth=2)
            
            plt.title('Portfolio Equity Curve')
            plt.ylabel('Portfolio Value')
            plt.xlabel('Time')
            plt.grid(True, alpha=0.3)
            plt.tight_layout()
            
            # Save figure to a BytesIO object
            img_data = BytesIO()
            plt.savefig(img_data, format='png')
            img_data.seek(0)
            plt.close()
            
            # Encode the image to base64
            encoded = base64.b64encode(img_data.read()).decode('utf-8')
            
            # Create HTML for the chart
            chart_html = f"""
            <div class="section">
                <h2>Portfolio Performance</h2>
                <div class="chart">
                    <img src="data:image/png;base64,{encoded}" class="img-fluid" alt="Equity Curve">
                </div>
            </div>
            """
            
            return chart_html
        except Exception as e:
            logger.error(f"Error generating equity curve chart: {e}")
            return ""
    
    def _generate_drawdown_chart(self, backtest_results):
        """Generate drawdown chart"""
        if 'drawdowns' not in backtest_results:
            return ""
        
        try:
            # Create a figure for the drawdown
            plt.figure(figsize=(10, 6))
            
            # Extract drawdowns
            drawdowns = backtest_results['drawdowns']
            
            # If we have a dictionary with dates
            if isinstance(drawdowns, dict):
                dates = list(drawdowns.keys())
                values = [float(v) * 100 for v in drawdowns.values()]
                
                # Try to parse dates
                try:
                    dates = [datetime.strptime(d, '%Y-%m-%d') for d in dates]
                    plt.fill_between(dates, values, 0, color='r', alpha=0.3)
                    plt.plot(dates, values, 'r-', linewidth=1)
                    plt.gca().xaxis.set_major_formatter(mdates.DateFormatter('%Y-%m-%d'))
                    plt.gca().xaxis.set_major_locator(mdates.MonthLocator(interval=3))
                except:
                    plt.fill_between(range(len(values)), values, 0, color='r', alpha=0.3)
                    plt.plot(values, 'r-', linewidth=1)
            else:
                values = [float(v) * 100 for v in drawdowns]
                plt.fill_between(range(len(values)), values, 0, color='r', alpha=0.3)
                plt.plot(values, 'r-', linewidth=1)
            
            plt.title('Drawdown')
            plt.ylabel('Drawdown (%)')
            plt.xlabel('Time')
            plt.grid(True, alpha=0.3)
            plt.tight_layout()
            
            # Save figure to a BytesIO object
            img_data = BytesIO()
            plt.savefig(img_data, format='png')
            img_data.seek(0)
            plt.close()
            
            # Encode the image to base64
            encoded = base64.b64encode(img_data.read()).decode('utf-8')
            
            # Create HTML for the chart
            chart_html = f"""
            <div class="section">
                <h2>Drawdown Analysis</h2>
                <div class="chart">
                    <img src="data:image/png;base64,{encoded}" class="img-fluid" alt="Drawdown">
                </div>
            </div>
            """
            
            return chart_html
        except Exception as e:
            logger.error(f"Error generating drawdown chart: {e}")
            return ""
    
    def _generate_relative_performance_chart(self, backtest_results, benchmark_comparison):
        """Generate relative performance chart"""
        if ('portfolio_values' not in backtest_results or 
            'benchmark_values' not in benchmark_comparison):
            return ""
        
        try:
            # Create a figure for the relative performance
            plt.figure(figsize=(10, 6))
            
            # Extract portfolio and benchmark values
            portfolio_values = backtest_results['portfolio_values']
            benchmark_values = benchmark_comparison['benchmark_values']
            benchmark_symbol = benchmark_comparison['benchmark_symbol']
            
            # If we have dictionaries with dates
            if (isinstance(portfolio_values, dict) and isinstance(benchmark_values, dict)):
                # Get common dates
                common_dates = sorted(set(portfolio_values.keys()) & set(benchmark_values.keys()))
                
                if common_dates:
                    # Normalize both series to start at 100
                    port_start = float(portfolio_values[common_dates[0]])
                    bench_start = float(benchmark_values[common_dates[0]])
                    
                    port_norm = [float(portfolio_values[d]) / port_start * 100 for d in common_dates]
                    bench_norm = [float(benchmark_values[d]) / bench_start * 100 for d in common_dates]
                    
                    # Try to parse dates
                    try:
                        dates = [datetime.strptime(d, '%Y-%m-%d') for d in common_dates]
                        plt.plot(dates, port_norm, 'b-', linewidth=2, label='Portfolio')
                        plt.plot(dates, bench_norm, 'g-', linewidth=2, label=benchmark_symbol)
                        plt.gca().xaxis.set_major_formatter(mdates.DateFormatter('%Y-%m-%d'))
                        plt.gca().xaxis.set_major_locator(mdates.MonthLocator(interval=3))
                    except:
                        plt.plot(port_norm, 'b-', linewidth=2, label='Portfolio')
                        plt.plot(bench_norm, 'g-', linewidth=2, label=benchmark_symbol)
            
            plt.title(f'Relative Performance vs {benchmark_symbol}')
            plt.ylabel('Normalized Value (100 = Start)')
            plt.xlabel('Time')
            plt.grid(True, alpha=0.3)
            plt.legend()
            plt.tight_layout()
            
            # Save figure to a BytesIO object
            img_data = BytesIO()
            plt.savefig(img_data, format='png')
            img_data.seek(0)
            plt.close()
            
            # Encode the image to base64
            encoded = base64.b64encode(img_data.read()).decode('utf-8')
            
            # Create HTML for the chart
            chart_html = f"""
            <div class="section">
                <h2>Relative Performance</h2>
                <div class="chart">
                    <img src="data:image/png;base64,{encoded}" class="img-fluid" alt="Relative Performance">
                </div>
            </div>
            """
            
            return chart_html
        except Exception as e:
            logger.error(f"Error generating relative performance chart: {e}")
            return ""
    
    def _generate_forecast_charts(self, forecasts, symphony_info):
        """Generate forecast charts for each symbol"""
        if not forecasts:
            return ""
        
        try:
            all_charts_html = '<div class="section"><h2>Forecast Charts</h2>'
            
            # For each symbol in the symphony
            for symbol in symphony_info['symbols']:
                if symbol not in forecasts:
                    continue
                    
                # Get the forecast data for this symbol
                symbol_forecast = forecasts[symbol]
                
                if not ('forecast_values' in symbol_forecast and symbol_forecast['forecast_values']):
                    continue
                    
                # Create a figure for this symbol's forecast
                plt.figure(figsize=(10, 6))
                
                forecast_data = symbol_forecast['forecast_values']
                
                # If we have a dictionary with dates
                if isinstance(forecast_data, dict):
                    # Split into history and forecast
                    dates = list(forecast_data.keys())
                    values = list(forecast_data.values())
                    
                    # Find where forecast starts
                    forecast_start_idx = -1
                    for i, d in enumerate(dates):
                        if d.startswith('forecast_'):
                            forecast_start_idx = i
                            break
                    
                    # If we found the forecast boundary
                    if forecast_start_idx > 0:
                        hist_dates = dates[:forecast_start_idx]
                        hist_values = values[:forecast_start_idx]
                        
                        forecast_dates = dates[forecast_start_idx:]
                        forecast_values = values[forecast_start_idx:]
                        
                        # Try to parse the real dates
                        try:
                            hist_dates = [datetime.strptime(d, '%Y-%m-%d') for d in hist_dates]
                            
                            # For forecast dates, remove 'forecast_' prefix and parse
                            forecast_dates = [datetime.strptime(d.replace('forecast_', ''), '%Y-%m-%d') 
                                            for d in forecast_dates]
                            
                            # Plot historical and forecast data
                            plt.plot(hist_dates, hist_values, 'b-', linewidth=2, label='Historical')
                            plt.plot(forecast_dates, forecast_values, 'r--', linewidth=2, label='Forecast')
                            
                            # Set nice date formatting
                            plt.gca().xaxis.set_major_formatter(mdates.DateFormatter('%Y-%m-%d'))
                            plt.gca().xaxis.set_major_locator(mdates.MonthLocator())
                        except:
                            # If date parsing fails, just use the raw values
                            plt.plot(hist_values, 'b-', linewidth=2, label='Historical')
                            plt.plot(range(len(hist_values), len(hist_values) + len(forecast_values)), 
                                    forecast_values, 'r--', linewidth=2, label='Forecast')
                
                plt.title(f'{symbol} Price Forecast')
                plt.ylabel('Price')
                plt.xlabel('Date')
                plt.grid(True, alpha=0.3)
                plt.legend()
                plt.tight_layout()
                
                # Save figure to a BytesIO object
                img_data = BytesIO()
                plt.savefig(img_data, format='png')
                img_data.seek(0)
                plt.close()
                
                # Encode the image to base64
                encoded = base64.b64encode(img_data.read()).decode('utf-8')
                
                # Add this symbol's chart to the HTML
                all_charts_html += f"""
                <div class="chart mt-4">
                    <h4>{symbol} Forecast</h4>
                    <img src="data:image/png;base64,{encoded}" class="img-fluid" alt="{symbol} Forecast">
                    <div class="mt-3">
                        <small>
                            7-Day Forecast: <span class="{self._get_color_class(symbol_forecast.get('7_day', {}).get('percent_change', 0))}">{symbol_forecast.get('7_day', {}).get('percent_change', 0):.2f}%</span>
                            | 30-Day Forecast: <span class="{self._get_color_class(symbol_forecast.get('30_day', {}).get('percent_change', 0))}">{symbol_forecast.get('30_day', {}).get('percent_change', 0):.2f}%</span>
                        </small>
                    </div>
                </div>
                """
            
            all_charts_html += '</div>'
            return all_charts_html
        except Exception as e:
            logger.error(f"Error generating forecast charts: {e}")
            return ""
    
    def _generate_risk_chart(self, risk_analysis):
        """Generate risk visualization chart as a horizontal bar chart"""
        if not risk_analysis:
            return ""
        
        try:
            # Create a horizontal bar chart for risk metrics
            plt.figure(figsize=(10, 6))
            
            # Define risk metrics to show
            metrics = [
                'Sharpe Ratio', 
                'Sortino Ratio', 
                'Calmar Ratio', 
                'Max Drawdown (%)', 
                'Volatility (%)', 
                'Downside Deviation (%)'
            ]
            
            # Get values (original values, not normalized)
            values = [
                risk_analysis.get('sharpe_ratio', 0),
                risk_analysis.get('sortino_ratio', 0),
                risk_analysis.get('calmar_ratio', 0),
                risk_analysis.get('max_drawdown', 0) * 100,  # Convert to percentage
                risk_analysis.get('volatility', 0) * 100,    # Convert to percentage
                risk_analysis.get('downside_deviation', 0) * 100  # Convert to percentage
            ]
            
            # Define colors based on what's good vs bad
            # For ratios (Sharpe, Sortino, Calmar): higher is better
            # For risk metrics (Drawdown, Volatility, Downside Dev): lower is better
            colors = []
            good_color = '#28a745'  # Green
            neutral_color = '#6c757d'  # Gray
            bad_color = '#dc3545'  # Red
            
            for i, val in enumerate(values):
                if i < 3:  # Ratios (higher is better)
                    if val > 1.5:
                        colors.append(good_color)
                    elif val > 0.5:
                        colors.append(neutral_color)
                    else:
                        colors.append(bad_color)
                else:  # Risk metrics (lower is better)
                    if val < 10:
                        colors.append(good_color)
                    elif val < 20:
                        colors.append(neutral_color)
                    else:
                        colors.append(bad_color)
            
            # Create horizontal bar chart
            y_pos = np.arange(len(metrics))
            ax = plt.barh(y_pos, values, align='center', color=colors, alpha=0.8)
            plt.yticks(y_pos, metrics)
            
            # Add value labels
            for i, v in enumerate(values):
                plt.text(max(v + 0.1, 0.1), i, f"{v:.2f}", va='center')
            
            # Set chart properties
            plt.xlabel('Value')
            plt.title('Risk Metrics')
            plt.grid(axis='x', alpha=0.3)
            
            # Different x-axis limits for ratios vs risk metrics
            # Find max value to set appropriate x-axis limit
            max_val = max(values) * 1.2  # Add 20% margin
            plt.xlim(0, max_val)
            
            plt.tight_layout()
            
            # Save figure to a BytesIO object
            img_data = BytesIO()
            plt.savefig(img_data, format='png')
            img_data.seek(0)
            plt.close()
            
            # Encode the image to base64
            encoded = base64.b64encode(img_data.read()).decode('utf-8')
            
            # Create HTML for the chart
            chart_html = f"""
            <div class="section">
                <h2>Risk Profile</h2>
                <div class="chart text-center">
                    <img src="data:image/png;base64,{encoded}" class="img-fluid" alt="Risk Profile">
                </div>
                <div class="mt-3">
                    <small class="text-muted">Note: For ratios (Sharpe, Sortino, Calmar), higher values are better. For risk metrics (Drawdown, Volatility, Downside Deviation), lower values are better.</small>
                </div>
            </div>
            """
            
            return chart_html
        except Exception as e:
            logger.error(f"Error generating risk chart: {e}")
            return ""
    
    def _generate_interactive_section(self, results):
        """Generate interactive charts with Chart.js"""
        if ('backtest_results' not in results or 
            'portfolio_values' not in results['backtest_results']):
            return ""
        
        try:
            # Create HTML for interactive section
            html = """
            <div class="section">
                <h2>Interactive Charts</h2>
                
                <ul class="nav nav-tabs" id="chartTabs" role="tablist">
                    <li class="nav-item" role="presentation">
                        <button class="nav-link active" id="equity-tab" data-bs-toggle="tab" data-bs-target="#equity-content" 
                                type="button" role="tab" aria-controls="equity-content" aria-selected="true">
                            Equity Curve
                        </button>
                    </li>
                    <li class="nav-item" role="presentation">
                        <button class="nav-link" id="drawdown-tab" data-bs-toggle="tab" data-bs-target="#drawdown-content" 
                                type="button" role="tab" aria-controls="drawdown-content" aria-selected="false">
                            Drawdown
                        </button>
                    </li>
            """
            
            # Add benchmark tab if available
            if ('benchmark_comparison' in results and 
                'benchmark_values' in results['benchmark_comparison']):
                html += """
                    <li class="nav-item" role="presentation">
                        <button class="nav-link" id="comparison-tab" data-bs-toggle="tab" data-bs-target="#comparison-content" 
                                type="button" role="tab" aria-controls="comparison-content" aria-selected="false">
                            Benchmark Comparison
                        </button>
                    </li>
                """
            
            html += """
                </ul>
                
                <div class="tab-content" id="chartTabsContent">
                    <div class="tab-pane fade show active" id="equity-content" role="tabpanel" aria-labelledby="equity-tab">
                        <div class="chart-container">
                            <canvas id="equityChart"></canvas>
                        </div>
                    </div>
                    <div class="tab-pane fade" id="drawdown-content" role="tabpanel" aria-labelledby="drawdown-tab">
                        <div class="chart-container">
                            <canvas id="drawdownChart"></canvas>
                        </div>
                    </div>
            """
            
            # Add benchmark comparison content if available
            if ('benchmark_comparison' in results and 
                'benchmark_values' in results['benchmark_comparison']):
                html += """
                    <div class="tab-pane fade" id="comparison-content" role="tabpanel" aria-labelledby="comparison-tab">
                        <div class="chart-container">
                            <canvas id="comparisonChart"></canvas>
                        </div>
                    </div>
                """
            
            html += """
                </div>
            """
            
            # Extract data for JavaScript
            portfolio_values = results['backtest_results']['portfolio_values']
            
            # Prepare JSON for Chart.js
            portfolio_data = {}
            if isinstance(portfolio_values, dict):
                portfolio_data = {
                    'labels': list(portfolio_values.keys()),
                    'values': list(portfolio_values.values())
                }
            else:
                portfolio_data = {
                    'labels': list(range(len(portfolio_values))),
                    'values': portfolio_values
                }
            
            # Add drawdown data if available
            drawdown_data = {}
            if 'drawdowns' in results['backtest_results']:
                drawdowns = results['backtest_results']['drawdowns']
                if isinstance(drawdowns, dict):
                    drawdown_data = {
                        'labels': list(drawdowns.keys()),
                        'values': [float(v) * 100 for v in drawdowns.values()]
                    }
                else:
                    drawdown_data = {
                        'labels': list(range(len(drawdowns))),
                        'values': [float(v) * 100 for v in drawdowns]
                    }
            
            # Add benchmark data if available
            benchmark_data = {}
            benchmark_symbol = ''
            if ('benchmark_comparison' in results and 
                'benchmark_values' in results['benchmark_comparison']):
                benchmark_values = results['benchmark_comparison']['benchmark_values']
                benchmark_symbol = results['benchmark_comparison']['benchmark_symbol']
                
                if isinstance(benchmark_values, dict):
                    benchmark_data = {
                        'labels': list(benchmark_values.keys()),
                        'values': list(benchmark_values.values())
                    }
                else:
                    benchmark_data = {
                        'labels': list(range(len(benchmark_values))),
                        'values': benchmark_values
                    }
            
            # Add JavaScript to initialize charts
            html += f"""
            <script>
                // Wait for DOM content to be loaded
                document.addEventListener('DOMContentLoaded', function() {{
                    // Portfolio equity chart
                    var ctxEquity = document.getElementById('equityChart').getContext('2d');
                    new Chart(ctxEquity, {{
                        type: 'line',
                        data: {{
                            labels: {json.dumps(portfolio_data['labels'])},
                            datasets: [{{
                                label: 'Portfolio Value',
                                data: {json.dumps(portfolio_data['values'])},
                                backgroundColor: 'rgba(54, 162, 235, 0.2)',
                                borderColor: 'rgba(54, 162, 235, 1)',
                                borderWidth: 2,
                                pointRadius: 0,
                                tension: 0.1
                            }}]
                        }},
                        options: {{
                            responsive: true,
                            maintainAspectRatio: false,
                            scales: {{
                                x: {{
                                    title: {{
                                        display: true,
                                        text: 'Date'
                                    }}
                                }},
                                y: {{
                                    title: {{
                                        display: true,
                                        text: 'Value'
                                    }}
                                }}
                            }},
                            plugins: {{
                                tooltip: {{
                                    intersect: false,
                                    mode: 'index'
                                }}
                            }}
                        }}
                    }});
            """
            
            # Add drawdown chart
            if drawdown_data:
                html += f"""
                    // Drawdown chart
                    var ctxDrawdown = document.getElementById('drawdownChart').getContext('2d');
                    new Chart(ctxDrawdown, {{
                        type: 'line',
                        data: {{
                            labels: {json.dumps(drawdown_data['labels'])},
                            datasets: [{{
                                label: 'Drawdown (%)',
                                data: {json.dumps(drawdown_data['values'])},
                                backgroundColor: 'rgba(255, 99, 132, 0.2)',
                                borderColor: 'rgba(255, 99, 132, 1)',
                                borderWidth: 2,
                                pointRadius: 0,
                                fill: true
                            }}]
                        }},
                        options: {{
                            responsive: true,
                            maintainAspectRatio: false,
                            scales: {{
                                x: {{
                                    title: {{
                                        display: true,
                                        text: 'Date'
                                    }}
                                }},
                                y: {{
                                    title: {{
                                        display: true,
                                        text: 'Drawdown (%)'
                                    }},
                                    reverse: true
                                }}
                            }},
                            plugins: {{
                                tooltip: {{
                                    intersect: false,
                                    mode: 'index'
                                }}
                            }}
                        }}
                    }});
                """
            
            # Add benchmark comparison chart
            if benchmark_data:
                html += f"""
                    // Benchmark comparison chart
                    var ctxComparison = document.getElementById('comparisonChart').getContext('2d');
                    
                    // Find common dates and normalize values
                    var portfolioDates = {json.dumps(portfolio_data['labels'])};
                    var benchmarkDates = {json.dumps(benchmark_data['labels'])};
                    var portfolioValues = {json.dumps(portfolio_data['values'])};
                    var benchmarkValues = {json.dumps(benchmark_data['values'])};
                    
                    // We need to normalize both datasets to start at 100
                    function normalizeData(dates, values) {{
                        if (dates.length === 0 || values.length === 0) return {{ dates: [], values: [] }};
                        
                        var startValue = parseFloat(values[0]);
                        var normalizedValues = values.map(v => parseFloat(v) / startValue * 100);
                        
                        return {{
                            dates: dates,
                            values: normalizedValues
                        }};
                    }}
                    
                    var normalizedPortfolio = normalizeData(portfolioDates, portfolioValues);
                    var normalizedBenchmark = normalizeData(benchmarkDates, benchmarkValues);
                    
                    new Chart(ctxComparison, {{
                        type: 'line',
                        data: {{
                            labels: normalizedPortfolio.dates,
                            datasets: [{{
                                label: 'Portfolio',
                                data: normalizedPortfolio.values,
                                backgroundColor: 'rgba(54, 162, 235, 0.2)',
                                borderColor: 'rgba(54, 162, 235, 1)',
                                borderWidth: 2,
                                pointRadius: 0,
                                tension: 0.1
                            }},
                            {{
                                label: '{benchmark_symbol}',
                                data: normalizedBenchmark.values,
                                backgroundColor: 'rgba(75, 192, 192, 0.2)',
                                borderColor: 'rgba(75, 192, 192, 1)',
                                borderWidth: 2,
                                pointRadius: 0,
                                tension: 0.1
                            }}]
                        }},
                        options: {{
                            responsive: true,
                            maintainAspectRatio: false,
                            scales: {{
                                x: {{
                                    title: {{
                                        display: true,
                                        text: 'Date'
                                    }}
                                }},
                                y: {{
                                    title: {{
                                        display: true,
                                        text: 'Value (Normalized to 100)'
                                    }}
                                }}
                            }},
                            plugins: {{
                                tooltip: {{
                                    intersect: false,
                                    mode: 'index'
                                }}
                            }}
                        }}
                    }});
                """
            
            html += """
                });
            </script>
            </div>
            """
            
            return html
        except Exception as e:
            logger.error(f"Error generating interactive section: {e}")
            return ""
    
    def _get_color_class(self, value):
        """Helper function to determine CSS class based on value"""
        if value > 0:
            return "positive"
        elif value < 0:
            return "negative"
        else:
            return "neutral"

def main():
    """
    Main function to test the report generator.
    """
    import argparse
    
    parser = argparse.ArgumentParser(description='Generate HTML reports from symphony analysis results')
    parser.add_argument('results_file', help='Path to the JSON results file from symphony_backtester')
    parser.add_argument('--output-dir', '-o', default='symphony_analysis_results', 
                      help='Output directory for the HTML report')
    parser.add_argument('--basic', '-b', action='store_true', 
                      help='Generate basic report without visualizations')
    
    args = parser.parse_args()
    
    # Configure logging
    logging.basicConfig(level=logging.INFO, 
                       format='%(asctime)s - %(name)s - %(levelname)s - %(message)s')
    
    # Load results from JSON file
    try:
        with open(args.results_file, 'r') as f:
            results = json.load(f)
    except Exception as e:
        logger.error(f"Error loading results file: {e}")
        return 1
    
    # Generate the HTML report
    generator = ReportGenerator(args.output_dir)
    
    if args.basic:
        report_file = generator.generate_basic_report(results)
    else:
        report_file = generator.generate_enhanced_report(results)
    
    if report_file:
        print(f"HTML report generated: {report_file}")
        return 0
    else:
        print("Failed to generate HTML report")
        return 1

if __name__ == "__main__":
    import sys
    sys.exit(main())